"""
Задание 2.

Попытайтесь выполнить профилирование памяти в любом скрипте с рекурсией.

Вам нужно обнаружить проблему в процессе этого. Но проблема связана не с тем,
что рекурсия потребляет много памяти, а с самим процессом замеров.

Опищите эту проблему и найдите простой путь ее решения.
Опишите этот путь и покажите его применение
"""
"""
Курс Алгоритмы Python. 2 Урок. Задание 2.
Подсчитать четные и нечетные цифры введенного натурального числа.
Например, если введено число 34560, то у него 3 четные цифры
(4, 6 и 0) и 2 нечетные (3 и 5).

Подсказка:
На каждом шаге вам нужно 'доставать' из числа очередную цифру
и смотреть является ли она четной или нечетной.
При этом увеличиваем соответствующий счетчик
Пока все числа не извлечены, рекурсивные вызовы продолжаем
Условие завершения рекурсии - все числа извлечены
Используем операции % //. Операции взятия по индексу применять нельзя.

Решите через рекурсию. В задании нельзя применять циклы.

Пример:
Введите число: 123
Количество четных и нечетных цифр в числе равно: (1, 2)
"""

from memory_profiler import memory_usage


def memory(f):
    def wrapper(*args, **kwargs):
        lst = list()
        res = f(*args, **kwargs)
        lst.append(memory_usage())
        print(f'Выполнение заняло {lst} MiB')
        return res
    return wrapper


@memory
def even_odd(n, i=0, j=0):
    residue = int(n) % 10
    n = int(n) // 10
    if residue % 2 == 0:
        i += 1
    else:
        j += 1
    if n > 0:
        return even_odd(n, i, j)
    else:
        return f'Количество четных цифр - {i} \n' \
               f'Количество нечетных цифр - {j}'


print(even_odd(input("Введите число: ")))

# Проблема профилирования функции с рекурсией в том, что каждый талица с данными вызывается с каждым вызовом функции,
# число вызовов функции равно числу таблиц с данными.
# Проблема решается функцией-декоратором @memory, результат инкремента сохраняется в lst при каждом вызове функции
# even_odd()
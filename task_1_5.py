"""
Задание 1.

Вам нужно взять 5 любых скриптов, написанных ВАМИ в рамках работы над ДЗ
курсов Алгоритмы и Основы Python

На каждый скрипт нужно два решения - исходное и оптимизированное.

Вы берете исходное, пишете что это за задание и с какого оно курса.
Далее выполняете профилирование скрипта средствами memory_profiler

Вы оптимизируете исходное решение.
Далее выполняете профилирование скрипта средствами memory_profiler

Вам нужно написать аналитику, что вы сделали для оптимизации памяти и
чего добились.


ВНИМАНИЕ:
1) скрипты для оптимизации нужно брать только из сделанных вами ДЗ
курсов Алгоритмы и Основы
2) нельзя дублировать, коды, показанные на уроке
3) для каждого из 5 скриптов у вас отдельный файл, в нем должна быть версия до
и версия после оптимизации
4) желательно выбрать те скрипты, где есть что оптимизировать и не брать те,
где с памятью и так все в порядке
5) не нужно писать преподавателю '''я не могу найти что оптимизировать''', это
отговорки. Примеров оптимизации мы перечислили много: переход с массивов на
генераторы, numpy, использование слотов, применение del, сериализация и т.д.

Это файл для пятого скрипта
"""
import json

"""
*(вместо задачи 3) Написать функцию thesaurus_adv(), принимающую в качестве аргументов
строки в формате «Имя Фамилия» и возвращающую словарь, в котором ключи — первые буквы
фамилий, а значения — словари, реализованные по схеме предыдущего задания и содержащие
записи, в которых фамилия начинается с соответствующей буквы. Например:
>>> thesaurus_adv("Иван Сергеев", "Инна Серова", "Петр
Алексеев", "Илья Иванов", "Анна Савельева")
{
  "А": {
      "П": ["Петр Алексеев"]
  },
  "И": {
      "И": ["Илья Иванов"]
  },
  "С": {
      "И": ["Иван Сергеев", "Инна Серова"],
      "А": ["Анна Савельева"]
  }
}
Как поступить, если потребуется сортировка по ключам?
"""

from memory_profiler import profile
from collections import defaultdict


# исходный код
@profile
def thesaurus_adv(*name_surenames):
    my_dict = {}
    for name_surename in name_surenames:
        name, sure_name = name_surename.split()
        my_dict.setdefault(sure_name[0], {})
        my_dict[sure_name[0]].setdefault(name[0], [])
        my_dict[sure_name[0]][name[0]].append(name_surename)
    sorted_dict = {x: my_dict[x] for x in sorted(my_dict)}
    print(my_dict)
    print(dict(sorted_dict))


thesaurus_adv("Иван Сергеев", "Инна Серова", "Петр Алексеев", "Илья Иванов", "Анна Савельева", "Ирина Светлова",
              "Марьяна Ладыгина", "Алина Семенова", "Евгений Антонов")


# оптимизированный код
@profile()
def thesaurus_adv(*name_surenames):
    my_dict = dict()
    for name_surename in name_surenames:
        name, sure_name = name_surename.split()
        my_dict.setdefault(sure_name[0], {})
        my_dict[sure_name[0]].setdefault(name[0], [])
        my_dict[sure_name[0]][name[0]].append(name_surename)
    sorted_dict = sorted(my_dict.items())
    return sorted_dict


with open("names_surnames.txt", "w", encoding="utf-8") as f:
    json.dump(
        thesaurus_adv("Иван Сергеев", "Инна Серова", "Петр Алексеев", "Илья Иванов", "Анна Савельева", "Ирина Светлова",
                      "Марьяна Ладыгина", "Алина Семенова", "Евгений Антонов"), f)


# применил сериализацию для записи имен и фамилий при помощи JSON, заменил dict comrehension на встроенную функцию
# sorted(). В итоге сэкономил 0,1 MiB.